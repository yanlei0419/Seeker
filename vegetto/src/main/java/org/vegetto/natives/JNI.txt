linux 下怎么用


1.window下怎么用
2.javac 编译.java文件
3.javah org.vegetto.natives.HelloWorld    //在bin目录或者 src 文件javah 编译
生成org_vegetto_natives_HelloWorld.h文件
4使用C-Free 5 工具,将.h头文件(org_vegetto_natives_HelloWorld.h )中的方法,实现c文件(org_vegetto_natives_HelloWorld.c ),并编译成dll文件(HImpl.dll)
其中.c文件中的方法名 需要加_才可以通过java实现(网上 也有说 可以不需要加)
方法实现 还需要把dll文件地址 制定给程序 才可加载到 动态库 (jawt_md.h,jni_md.h,jni.h)
System.loadLibrary("HImpl");//  HImpl为编译成的dll文件


http://blog.csdn.net/yanzi1225627/article/details/18891613
http://www.cnblogs.com/hanyuanbo/archive/2012/07/10/2584758.html
http://blog.csdn.net/jjunjoe/article/details/6987183
http://www.cnblogs.com/fww330666557/archive/2012/12/14/2817387.html



一、JNI介绍
JNI（Java Native Interface），即JAVA本地接口，是为java编写本地方法和jvm嵌入本地应用程序的标准的应用程序接口。
首要的目标是在给定的平台上采用Java通过JNI调用本地方法，而本地方法是以库文件的形式存放的（在WINDOWS平台上是DLL文件形式，在UNIX机器上是SO文件形式）。
通过调用本地的库文件的内部方法，使Java可以实现和本地机器的紧密联系，调用系统级的各接口方法。有的jvm来实现兼容的二进制编码本地方法库。
二、环境介绍
Eclipse kepler版本
Java Development Kit (JDK)1.7版本
Gcc编译器编译生成C语言的so动态链接库文件
三、简述步骤
编写带有native声明方法的java类
使用c/c++实现本地方法，并生成动态连接库so
为动态连接库so设置软连接路径
运行java程序，调用so库
四、具体实现
（1）编写java程序
 在java程序中，首先需要在类中声明所调用的库名称，如下：
DataInteract .java
package com.minaServer;


public class DataInteract {
	public native void dataProvider(byte[] buf,int len);//提供一次打包数据
	public native void DecodeInit(int bsize);//根据客户端连接数返回buffer大小
	public native void DecodeSetupBound(int size);
	public native void DecodeExit();
	
	static {         
		     System.loadLibrary("NativeDecode");   //调用第三方库
		    }
}

 库的扩展名字不用写出来是so还是dll，程序自己判断。
（2）编译java程序
 
（3）创建.h文件
       需要使用javah工具创建DataInteract.java源文件的.h头文件
1、	使用echo $JAVA_HOME查找jdk安装目录
root@zhang-System-Product-Name: # echo $JAVA_HOME
/usr/lib/jdk/jdk1.7.0_79
2、	进入bin目录使用javah工具
javah工具的使用方法
Usage: 
  javah [options] <classes>
where [options] include:
  -o <file>                Output file (only one of -d or -o may be used)
  -d <dir>                 Output directory
  -v  -verbose             Enable verbose output
  -h  --help  -?           Print this message
  -version                 Print version information
  -jni                     Generate JNI-style header file (default)
  -force                   Always write output files
  -classpath <path>        Path from which to load classes
  -bootclasspath <path>    Path from which to load bootstrap classes


root@zhang-System-Product-Name:/usr/lib/jdk/jdk1.7.0_79/bin# ./javah -d /home/zhang -classpath /home/zhang/suly/雷达/NewIVTBackend/build/classes  com.minaServer.DataInteract 
Workspace下
-d表示将产生的.h头文件输出在 指定的目录/home/zhang下
-classpath 表示上面第二步编译后的java源文件所在目录/home/zhang/suly/雷达/NewIVTBackend/build/classes
使用上面语句会自动生成名为com_minaServer_DataInteract.h的头文件

com_minaServer_DataInteract.h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_minaServer_DataInteract */

#ifndef _Included_com_minaServer_DataInteract
#define _Included_com_minaServer_DataInteract
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_minaServer_DataInteract
 * Method:    dataProvider
 * Signature: ([BI)V
 */
JNIEXPORT void JNICALL Java_com_minaServer_DataInteract_dataProvider
  (JNIEnv *, jobject, jbyteArray, jint);

/*
 * Class:     com_minaServer_DataInteract
 * Method:    DecodeInit
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_com_minaServer_DataInteract_DecodeInit
  (JNIEnv *, jobject, jint);

/*
 * Class:     com_minaServer_DataInteract
 * Method:    DecodeSetupBound
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_com_minaServer_DataInteract_DecodeSetupBound
  (JNIEnv *, jobject, jint);

/*
 * Class:     com_minaServer_DataInteract
 * Method:    DecodeExit
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_minaServer_DataInteract_DecodeExit
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif



（4）编译c程序
         需将第三步生成的.h头文件和系统文件jni.h与jni_md.h拷贝到c/c++项目文件夹中。
 jni.h存放在JAVA_HOME所在目录下的include目录下
jni_md.h存放在JAVA_HOME所在目录的include/linux目录下
注意:在拷贝com_minaServer_DataInteract.h到c/c++目标目录前需修改#include <jni.h>为#include “jni.h”

在c语言中实现程序时需要使用include引入头文件
编写完c程序后，用gcc编译时需带上 -shared –fPIC 两个编译项。
（5）配置so为系统库
1、通过调用系统方法 System.getProperty（）查找linux下java加载so的路径。可通过程序查找默认加载路径：

Pathload.java
public class pathload {

	public static void main(String[] args) {
		System.out.println(System.getProperty("java.library.path"));
	}

}
打印信息如下：
/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib

	
2、软链接设置
    例如：
    c/c++的程序所在目录为：/home/zhang/NativeDecode/
    编译成功的so名字为：NativeDecode.so
    具体步骤如下：
    a、获取root权限
        su
    b、建立软连接
ln -s  /home/zhang/NativeDecode/NativeDecode.so /usr/lib/libNativeDecode.so  

注:和windows下不同，linux的库文件必须是以libxxx.so形式命令的(或者 libxxx.so.y，y是版本号)，lib前缀是为了系统能够识别它，xxx是java代码System.loadLibrary("xxx");中引用库的名字。



windos 下怎么用


问题背景：之前的JNI编程都是基于Android的NDK工具，生成so文件供android端调用，参见：http://blog.csdn.net/yanzi1225627/article/details/8525720 现在的目标是用eclipse CDT MinGW编写C++文件生成PC上可用的动态链接库dll，供纯Java调用。本以为很简单，可没想到折腾到半夜两点没搞定，原因是很多参考文献资料太老了。好吧，大年初一搞了两个小时终于拿下。下面是详细步骤:

准备工作:

	将C:\Program Files\Java\jdk1.7.0_45\include路径下的jni.h和C:\Program Files\Java\jdk1.7.0_45\include\win32路径下的jni_md.h拷贝到MinGW下的include路径下，否则会出现找不到#include<jni.h>及不认关键字:JNIEXPORT JNICALL JNIEnv的情况。参考文献中将这两个路径直接添加到了C++工程属性里的General---Paths and Symbols---GNU C++的include栏，如下图:



而实际上是没有必要的，只需按上面的拷贝两个h文件到相应位置即可！

1、新建一个Java project，包名为org.yanzi.learnjni,主类为LearnJNI，即带有main函数的类。为了使代码结构有条理性，再新建一个包：org.yanzi.mylib，新建一个类JNILib.java.代码如下：


[java] view plain copy print?在CODE上查看代码片派生到我的代码片
package org.yanzi.mylib;  
  
public class JNILib {  
    static{  
        System.loadLibrary("");  
    }  
    public static native void jniPrint(String str);  
}  

我们在这个类里将本地库加载进来，由于本地库还么有生成，所有System.loadLibrary()函数里的参数暂时不写。最关键的是下面那句话，声明了jni里的函数原型，输入一个String然后再jni里打印出来。
2、然后我们在cmd里利用javah生成与JNILib.java里jniPrint()函数相对应的JNI的声明。cmd里进到所在工程目录的src文件夹下:E:\WorkSpaces\Eclipse_Java\LearnJNI\src. 输入命令:javah org.yanzi.mylib.JNILib

注意：一定要在src文件夹下输入javah，只有这样后面的org.yanzi.mylib.JNILib（包名 + 类名）路径才能对的上。



刷新工程，就会看到生成的.h文件：



3、新建一个C++工程，如下图:



	注意这个C++工程的名字就是未来生成的dll的名字libXXX.dll。这一点跟ndk不同，ndk是通过mk文件指定动态链接库的名字的。然后点击next，再新建一个src文件夹，不是必须的，仅仅是为了让程序更加规整.然后将刚才生成的org_yanzi_mylib_JNILib.h拷贝到这个src文件夹下，再新建一个cpp文件。之后这个.h文件在java工程就么有作用了，删除掉也是可以的，不过为了告诉Java调用的人接口是什么，这个h文件就要保留下。为了统一，cpp文件取名为:org_yanzi_mylib_JNILib.cpp.

原来生成的.h文件里没有形参，加形参后函数体为:

JNIEXPORT void JNICALL Java_org_yanzi_mylib_JNILib_jniPrint
  (JNIEnv *env, jclass jthis, jstring str);

org_yanzi_mylib_JNILib.h文件的内容如下:


[cpp] view plain copy print?在CODE上查看代码片派生到我的代码片
/* DO NOT EDIT THIS FILE - it is machine generated */  
#include <jni.h>  
/* Header for class org_yanzi_mylib_JNILib */  
  
#ifndef _Included_org_yanzi_mylib_JNILib  
#define _Included_org_yanzi_mylib_JNILib  
#ifdef __cplusplus  
extern "C" {  
#endif  
/* 
 * Class:     org_yanzi_mylib_JNILib 
 * Method:    jniPrint 
 * Signature: (Ljava/lang/String;)V 
 */  
JNIEXPORT void JNICALL Java_org_yanzi_mylib_JNILib_jniPrint  
  (JNIEnv *env, jclass jthis, jstring str);  
  
#ifdef __cplusplus  
}  
#endif  
#endif  
org_yanzi_mylib_JNILib.cpp文件的内容如下:
[cpp] view plain copy print?在CODE上查看代码片派生到我的代码片
/* 
 * org_yanzi_mylib_JNILib.cpp 
 * 
 *  Created on: 2014-2-1 
 *      Author: Administrator 
 */  
#include "org_yanzi_mylib_JNILib.h"  
#include <iostream>  
using namespace std;  
JNIEXPORT void JNICALL Java_org_yanzi_mylib_JNILib_jniPrint  
  (JNIEnv *env, jclass jthis, jstring str){  
    jboolean iscopy = false;  
    const char *charData = env->GetStringUTFChars(str, &iscopy);  
    cout << "Hello, this is from JNI(dll)" <<endl;  
    cout<<"The data from java is:"<<charData << endl;  
    env->ReleaseStringUTFChars(str, charData);  
}  
[关键一步]选中工程，按alt+enter，在Build----Settings----Tool Settings-----MinGW C++ Linker目录栏下的Miscellaneous选项下，在linker flags处填入:-Wl,--add-stdcall-alias


然后点击编译，在Debug目录下生成libMyJNILib.dll，libXXX.dll名字可以发现XXX就是我们起的C++的工程名字.



4、生成dll完毕后，C++的就告一段落了。在java工程里新建一个文件夹libs,该文件夹路径跟src在同一级目录。将生成的dll拷贝到libs文件夹。

5、[关键一步]在System.loadLibrary()函数里写入参数:libMyJNILib,注意而不是MyJNILib,一定是全名，此处和ndk-build生成so不同。JNILib.java代码如下:


[java] view plain copy print?在CODE上查看代码片派生到我的代码片
package org.yanzi.mylib;  
  
public class JNILib {  
    static{  
        System.loadLibrary("libMyJNILib");  
    }  
    public static native void jniPrint(String str);  
}  

LearnJNI.java代码如下:

[java] view plain copy print?在CODE上查看代码片派生到我的代码片
package org.yanzi.learnjni;  
  
import org.yanzi.mylib.JNILib;  
  
public class LearnJNI {  
  
    /** 
     * @param args 
     */  
    public static void main(String[] args) {  
        // TODO Auto-generated method stub  
        JNILib.jniPrint("123456");  
    }  
  
}  

此刻，点击run会报错如下,java.lang.UnsatisfiedLinkError错误:

[java] view plain copy print?在CODE上查看代码片派生到我的代码片
Exception in thread "main" java.lang.UnsatisfiedLinkError: no libMyJNILib in java.library.path  
    at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1886)  
    at java.lang.Runtime.loadLibrary0(Runtime.java:849)  
    at java.lang.System.loadLibrary(System.java:1088)  
    at org.yanzi.mylib.JNILib.<clinit>(JNILib.java:5)  
    at org.yanzi.learnjni.LearnJNI.main(LearnJNI.java:12)  
所以还需要下面重要一步。
6、[关键一步]选中工程，依次点击run---run configurations---LearnJNI,在点击Arguments，在Vm arguments处填入如下：-Djava.library.path="${workspace_loc}\LearnJNI\libs;${env_var:PATH}"

注意：上面这句话一点都不能错，其中LearnJNI是java的工程的名字。两头的引号不要少，另外里面是\，因为这是windows下。

经过这些后，点击run，久违的打印出现了:


另外，在	static{
		System.loadLibrary("libMyJNILib");
	}里可以加上一句:System.out.println(System.getProperty("java.library.path"));打印path的所有路径。整体代码如下:
[java] view plain copy print?在CODE上查看代码片派生到我的代码片
package org.yanzi.mylib;  
  
public class JNILib {  
    static{  
        System.out.println(System.getProperty("java.library.path"));  
        System.loadLibrary("libMyJNILib");  
    }  
    public static native void jniPrint(String str);  
}  

总结，网上常见的误解之处：
1、将mingw里的bin文件夹下的mingw32-make.exe改名为make.exe,这一步完全是多余的！
2、在C++的cpp和h文件里，将函数的申明(Java关键字前面)加个下划线_. 如JNIEXPORT void JNICALL _Java_org_yanzi_mylib_JNILib_jniPrint
  (JNIEnv *env, jclass jthis, jstring str) 事实证明这一步是多余的！
3、在-Djava.library.path的配置里一定要带“”，有的教程上写的是: .;./libs，经过打印path印证，这完全就是扯淡！本博文里的配置才是正确的。
4、有的博文说C++的代码里才cpp的名字必须和.h名字一样，这也是扯淡。
5、还有的说生成的h文件原封不动的拷贝到cpp文件里，这样做当然是可以的。但是保留h文件，在cpp文件里include进来也是可以的，推荐这样做，这会让程序显得规整些。

参考：http://jingyan.baidu.com/article/9c69d48f53575d13c9024ec1.html

---------------------本文系原创，转载请注明作者:yanzi1225627
代码下载(C++和Java的)：http://download.csdn.net/detail/yanzi1225627/6893971
















